
/**
 * Core Philosophy: This ruleset enforces a strict, role-based access control (RBAC) model.
 * A user's identity is verified through Firebase Authentication. Their authorization
 * level is determined by the existence of a document corresponding to their UID in the
 * `/roles_admin` collection. Users with such a document are considered 'Admins' and are
 * granted full read and write access to most data collections. Regular authenticated users
 * are granted read-only access to non-sensitive data like products and locations, and can
 * create sales records.
 *
 * Data Structure: The data is organized into flat, top-level collections representing
 * core business entities (products, locations, inventories, etc.). This design simplifies
 * security rules, as access control is uniform across all data, and promotes efficient,
 * scalable queries. Nested data is used for items within sales and stock counts.
 *
 * Key Security Decisions:
 * - Admin-Only Write Access (mostly): Most data modification operations (create, update, delete)
 *   are restricted to authenticated users who have the 'admin' role. The exception is sales creation.
 * - Sales Creation: Any authenticated user can create sales records, necessary for POS functionality.
 * - Authenticated Read Access: Read access to core data like products and locations is
 *   granted to any signed-in user.
 * - Default Deny: The default security posture is to deny all access. Permissions are
 *   granted explicitly.
 * - No Public Access: There are no publicly readable or writable collections.
 * - Admin Management: Only existing admins can add or remove other admins.
 *
 * Denormalization for Authorization: The use of a dedicated `/roles_admin/{userId}`
 * collection is a key denormalization strategy. Instead of checking a field on a user
 * profile, the rules perform a highly efficient `exists()` check against this collection.
 * This decouples the authorization model from the user data model and avoids slow,
 * costly `get()` calls in rules.
 *
 * Structural Segregation: Each primary data entity resides in its own top-level collection.
 * This segregation ensures that list queries are secure and performant, as all documents
 * within a collection share the same access control policy.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // --------------------------------
    // Helper Functions
    // --------------------------------

    /**
     * Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the authenticated user has an admin role.
     * The role is granted by the existence of a document in the /roles_admin collection
     * with an ID matching the user's UID.
     */
    function isAdmin() {
      return exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }
    
    /**
     * Checks if the requesting user is the owner of the document.
     */
    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    /**
     * Validates that the stock count item being created belongs to the parent stock count.
     */
    function isValidStockCountItemCreate(stockCountId) {
      return request.resource.data.stockCountId == stockCountId;
    }
    
    /**
     * Validates that the sale item being created belongs to the parent sale.
     */
    function isValidSaleItemCreate(saleId) {
      return request.resource.data.saleId == saleId;
    }

    /**
     * Enforces immutability of the stockCountId field on update.
     */
    function isStockCountItemRelationImmutable() {
      return request.resource.data.stockCountId == resource.data.stockCountId;
    }
    
    /**
     * Enforces immutability of the saleId field on update.
     */
    function isSaleItemRelationImmutable() {
      return request.resource.data.saleId == resource.data.saleId;
    }

    // --------------------------------
    // Collection Group Rules
    // --------------------------------

    /**
     * @description Allows any signed-in user to query across all `items` subcollections.
     * @path /{path=**}/items/{itemId}
     * @allow A signed-in user (list).
     * @principle This is necessary for the "Sales by Product" report, which uses a collection group query.
     */
    match /{path=**}/items/{itemId} {
      allow list: if isSignedIn();
    }


    // --------------------------------
    // Collection Rules
    // --------------------------------

    /**
     * @description Manages public user profiles. Admins can manage any user. Users can create their own profile.
     * @path /users/{userId}
     * @allow Admins can manage all. Users can create and read their own doc.
     * @principle Secures user data while allowing admins to manage accounts and users to sign up and view their own profile.
     */
    match /users/{userId} {
        allow create: if isSignedIn() && isOwner(userId);
        allow read, write: if isSignedIn() && isAdmin();
        allow get: if isSignedIn() && isOwner(userId);
    }


    /**
     * @description Manages the product catalog. Any signed-in user can read and modify.
     * @path /products/{productId}
     * @allow A signed-in user (create, get, list, update, delete).
     * @principle Allows any authenticated user to manage the product catalog.
     */
    match /products/{productId} {
      allow read, write: if isSignedIn();
    }

    /**
     * @description Manages storage locations. Any signed-in user can read, but only admins can modify.
     * @path /locations/{locationId}
     * @allow A signed-in user (list): `request.auth` is not null.
     * @deny An unauthenticated user (update): `request.auth` is null.
     * @principle Separates read and write access for different user levels.
     */
    match /locations/{locationId} {
      allow get: if isSignedIn();
      allow list: if isSignedIn();
      allow create: if isSignedIn() && isAdmin();
      allow update: if isSignedIn() && isAdmin() && resource != null;
      allow delete: if isSignedIn() && isAdmin() && resource != null;
    }

    /**
     * @description Manages inventory levels. Only admins can read or modify inventory records.
     * @path /inventories/{inventoryId}
     * @allow An admin user (update): `auth.uid` has a doc in `/roles_admin`.
     * @deny A non-admin user (delete): `auth.uid` does not have a doc in `/roles_admin`.
     * @principle Enforces global admin role for all data access.
     */
    match /inventories/{inventoryId} {
      allow get: if isSignedIn() && isAdmin();
      allow list: if isSignedIn() && isAdmin();
      allow create: if isSignedIn() && isAdmin();
      allow update: if isSignedIn() && isAdmin() && resource != null;
      allow delete: if isSignedIn() && isAdmin() && resource != null;
    }

    /**
     * @description Manages low stock alerts. Only admins can read or manage these alerts.
     * @path /low_stock_alerts/{lowStockAlertId}
     * @allow An admin user (delete): `auth.uid` has a doc in `/roles_admin`.
     * @deny A non-admin user (create): `auth.uid` does not have a doc in `/roles_admin`.
     * @principle Enforces global admin role for all data access.
     */
    match /low_stock_alerts/{lowStockAlertId} {
      allow get: if isSignedIn() && isAdmin();
      allow list: if isSignedIn() && isAdmin();
      allow create: if isSignedIn() && isAdmin();
      allow update: if isSignedIn() && isAdmin() && resource != null;
      allow delete: if isSignedIn() && isAdmin() && resource != null;
    }

    /**
     * @description Manages stock count events. Only admins can read or manage these events.
     * @path /stock_counts/{stockCountId}
     * @allow An admin user (create): `auth.uid` has a doc in `/roles_admin`.
     * @deny A non-admin user (get): `auth.uid` does not have a doc in `/roles_admin`.
     * @principle Enforces global admin role for all data access.
     */
    match /stock_counts/{stockCountId} {
      allow get: if isSignedIn() && isAdmin();
      allow list: if isSignedIn() && isAdmin();
      allow create: if isSignedIn() && isAdmin();
      allow update: if isSignedIn() && isAdmin() && resource != null;
      allow delete: if isSignedIn() && isAdmin() && resource != null;

      /**
       * @description Manages items within a stock count. Access is inherited from the parent.
       * @path /stock_counts/{stockCountId}/stock_count_items/{stockCountItemId}
       * @allow An admin user (create): `auth.uid` has a doc in `/roles_admin` and `stockCountId` in data matches the path.
       * @deny An admin user (create): The `stockCountId` in the document data does not match the document path.
       * @principle Enforces global admin role and validates relational integrity between parent and child documents.
       */
      match /stock_count_items/{stockCountItemId} {
        allow get: if isSignedIn() && isAdmin();
        allow list: if isSignedIn() && isAdmin();
        allow create: if isSignedIn() && isAdmin() && isValidStockCountItemCreate(stockCountId);
        allow update: if isSignedIn() && isAdmin() && resource != null && isStockCountItemRelationImmutable();
        allow delete: if isSignedIn() && isAdmin() && resource != null;
      }
    }
    
    /**
     * @description Manages completed sales records. Any signed-in user can create and read sales. Admins can read/update/delete.
     * @path /sales/{saleId}
     * @allow Any signed-in user to create or read. Admins for other operations.
     * @principle Secures financial data by restricting access while allowing POS functionality and sales history viewing.
     */
    match /sales/{saleId} {
      allow create: if isSignedIn();
      allow get: if isSignedIn();
      allow list: if isSignedIn();
      allow update: if isSignedIn() && isAdmin() && resource != null;
      allow delete: if isSignedIn() && isAdmin() && resource != null;

      /**
       * @description Manages items within a sale. Access is inherited from the parent sale.
       * @path /sales/{saleId}/items/{itemId}
       * @allow Any signed-in user to create items as part of their sale and read them. Admins for other operations.
       * @principle Ensures that sale items are correctly associated with a sale.
       */
      match /items/{itemId} {
        allow create: if isSignedIn() && isValidSaleItemCreate(saleId);
        allow get: if isSignedIn();
        // The collection group query rule above handles list operations for reports.
        allow update: if isSignedIn() && isAdmin() && resource != null && isSaleItemRelationImmutable();
        allow delete: if isSignedIn() && isAdmin() && resource != null;
      }
    }

    /**
     * @description Manages admin roles. Users can read their own role. Admins manage all roles.
     * @path /roles_admin/{userId}
     * @allow A user to get their own role. Admins can manage all roles.
     * @deny A non-admin user from accessing other users' roles.
     * @principle Secures the authorization system while allowing self-lookup for UI rendering.
     */
    match /roles_admin/{userId} {
      allow get: if isSignedIn() && (isAdmin() || isOwner(userId));
      allow list: if isSignedIn() && isAdmin();
      allow create, update, delete: if isSignedIn() && isAdmin();
    }
  }
}

    